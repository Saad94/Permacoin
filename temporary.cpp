/*
* g++ -std=c++11 test.cpp $(pkg-config --libs libcrypto)
*/

#include <vector>
#include <sys/stat.h>
#include "src/secp256k1/include/secp256k1.h"
#include "src/uint256.cpp"
#include "src/hash.cpp"
#include "src/streams.h"
#include "src/arith_uint256.cpp"
// #include "src/key.h"
#include <iostream>
#include <fstream>
#include <sstream>
using namespace std;

// static secp256k1_context_t* secp256k1_context = NULL;

// bool CKey::Check(const unsigned char *vch) {
//     return eccrypto::Check(vch);
// }

// void CKey::MakeNewKey(bool fCompressedIn) {
//     RandAddSeedPerfmon();
//     do {
//         GetRandBytes(vch, sizeof(vch));
//     } while (!Check(vch));
//     fValid = true;
//     fCompressed = fCompressedIn;
// }

// bool CKey::SetPrivKey(const CPrivKey &privkey, bool fCompressedIn) {
//     if (!secp256k1_ec_privkey_import(secp256k1_context, (unsigned char*)begin(), &privkey[0], privkey.size()))
//         return false;
//     fCompressed = fCompressedIn;
//     fValid = true;
//     return true;
// }

// CPrivKey CKey::GetPrivKey() const {
//     assert(fValid);
//     CPrivKey privkey;
//     int privkeylen, ret;
//     privkey.resize(279);
//     privkeylen = 279;
//     ret = secp256k1_ec_privkey_export(secp256k1_context, begin(), (unsigned char*)&privkey[0], &privkeylen, fCompressed);
//     assert(ret);
//     privkey.resize(privkeylen);
//     return privkey;
// }

// CPubKey CKey::GetPubKey() const {
//     assert(fValid);
//     CPubKey result;
//     int clen = 65;
//     int ret = secp256k1_ec_pubkey_create(secp256k1_context, (unsigned char*)result.begin(), &clen, begin(), fCompressed);
//     assert((int)result.size() == clen);
//     assert(ret);
//     assert(result.IsValid());
//     return result;
// }






// ==================================================================================

/*
* Server breaks file into n = rf segments.
* For testing, r = 2, f = 293, size_of_segment = 2176 bytes
*
* Server computes hash of every segment and publishes it. 
* During initial download, Client chooses 'l' segments to store. Constructs merkle
* tree from all 'n' segments, and stores Merkle proofs for each of its 'l' segments.
* 
* A Merkle proof consists of a string of a concatenated series of 256bit hashes.
* 
* During mining, the Client generates nonce's denoted by 's'.
* 
* 
* 
* 
* 
* 
*  
*/

class CKey {
  public:
  	void MakeNewKey(bool fCompressed) {}
  	void Sign(uint256 u, vector<unsigned char> v) {}
  	CPubKey GetPubKey() const {return CPubKey();}
};

// class CPubKey {

// };

// ==================================================================================

ostream& operator<<(ostream& os, const vector<unsigned char>& v) {
	for (int i = 0; i < v.size(); i++) {
		os << v[i];
	}
	return os;
}


uint256 CheckMerkleBranch(uint256 hash, const vector<uint256>& vMerkleBranch, int nIndex)
{
    if (nIndex == -1)
        return uint256();
    for (vector<uint256>::const_iterator it(vMerkleBranch.begin()); it != vMerkleBranch.end(); ++it)
    {
        if (nIndex & 1)
            hash = Hash(BEGIN(*it), END(*it), BEGIN(hash), END(hash));
        else
            hash = Hash(BEGIN(hash), END(hash), BEGIN(*it), END(*it));
        nIndex >>= 1;
    }
    return hash;
}

// ==================================================================================

CKey 					ck 					 ;  // The client's CKey. Can be used to generate pk and sk. Used for signing.
CPubKey  				pk 					 ;  // public key of client. Used for verifying.
int 					n 				=1174;	// total no. of segments.
const uint32_t 			l 				=  20;	// no. of segments each client stores.
const uint32_t 			k 				=   5;  // no. of challenges.
int 					u[l]			 	 ;  // indices of segments which the client stores.
vector<string> 			m_proof[l]			 ;  // merkle proofs of segments which the client stores.
int 					r_u_index[k+1]	 	 ; 	// values by which 'u' will be indexed
int 					r[k+1]			 	 ;  // indices of challenged segments.
uint256 				h[k] 				 ;  // hashes used for signing and generating challenge indices.
vector<unsigned char> 	sig[k+1] 			 ;  // array of signatures generated by calling ck.Sign
string 					merkleRoot			 ;  // root hash of the merkle tree

FILE*  					fp 					 ;  // pointer to the file segments that will be read in and hashed.
struct stat 			status 				 ;	// finding file size
int 					filesize 		=	0;  // size of the buffer
unsigned char* 			buffer 				 ;  // to read the file into
vector<unsigned char*> 	files(k)			 ;
char*					filenamePaddingBuf 	 ;
int 					filenamePadding 	 ;
char* 					filepath 			 ;
ifstream 				fs 					 ;

int 					nNonce 			= 	2151650;
string 					baseFilepath	=  "/home/saad/Desktop/Jerasure-1.2/Examples/Coding/";


// ==================================================================================

int main() {
	filepath = (char*) malloc(sizeof(char)*30 + baseFilepath.length());
	sprintf(filepath, "%stest.txt", baseFilepath.c_str());
	
	fp = fopen(filepath, "rb");
	if (fp == NULL) {
		printf("===========================\nERROR: UNABLE TO OPEN FILE.\n\n");
		exit(0);
	}
	if (filesize == 0) {
		stat(filepath, &status);
		filesize = status.st_size;
	}

	buffer = (unsigned char*)malloc(sizeof(unsigned char)*filesize);

	fread((void*)buffer, sizeof(char), filesize, fp);

	fclose(fp);

	// printf("BUFFER = \n%s\n\n", buffer);

	sig[0] = {'0', '1', '2', '3', '5'};
	m_proof[0] = {"abc", "def", "ghi", "jkl"};

	CDataStream ss1(1, 2);
	char br = '\n';

	ss1 << pk << br;

	char temp[10];
	sprintf(temp, "%d", nNonce);
	for (int i = 0; i < strlen(temp); i++) {
		ss1 << temp[i];
	}
	ss1 << br;
	
	for (int i = 0; i < 1; i++) {
		ss1.write((char*)buffer, filesize);
		ss1 << br << br << sig[0];
		ss1 << br << br;
		for (int j = 0; j < m_proof[0].size(); j++) {
			for (char c : m_proof[0][j]) {
				ss1 << c;
			}
			ss1 << ',';
		}
	}
	cout << "STREAM = " << ss1.str() << "\n";
	// ticket_hasher.Write((unsigned char*)&ss[0], 76);

	return 0;
}
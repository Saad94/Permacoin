#include <vector>
#include <sys/stat.h>
#include "src/secp256k1/include/secp256k1.h"
#include "src/uint256.cpp"
#include "src/hash.cpp"
// #include "src/key.h"
#include <iostream>
using namespace std;

// static secp256k1_context_t* secp256k1_context = NULL;

// bool CKey::Check(const unsigned char *vch) {
//     return eccrypto::Check(vch);
// }

// void CKey::MakeNewKey(bool fCompressedIn) {
//     RandAddSeedPerfmon();
//     do {
//         GetRandBytes(vch, sizeof(vch));
//     } while (!Check(vch));
//     fValid = true;
//     fCompressed = fCompressedIn;
// }

// bool CKey::SetPrivKey(const CPrivKey &privkey, bool fCompressedIn) {
//     if (!secp256k1_ec_privkey_import(secp256k1_context, (unsigned char*)begin(), &privkey[0], privkey.size()))
//         return false;
//     fCompressed = fCompressedIn;
//     fValid = true;
//     return true;
// }

// CPrivKey CKey::GetPrivKey() const {
//     assert(fValid);
//     CPrivKey privkey;
//     int privkeylen, ret;
//     privkey.resize(279);
//     privkeylen = 279;
//     ret = secp256k1_ec_privkey_export(secp256k1_context, begin(), (unsigned char*)&privkey[0], &privkeylen, fCompressed);
//     assert(ret);
//     privkey.resize(privkeylen);
//     return privkey;
// }

// CPubKey CKey::GetPubKey() const {
//     assert(fValid);
//     CPubKey result;
//     int clen = 65;
//     int ret = secp256k1_ec_pubkey_create(secp256k1_context, (unsigned char*)result.begin(), &clen, begin(), fCompressed);
//     assert((int)result.size() == clen);
//     assert(ret);
//     assert(result.IsValid());
//     return result;
// }






// ==================================================================================

/*
* Server breaks file into n = rf segments.
* For testing, r = 2, f = 293, size_of_segment = 2176 bytes
*
* Server computes hash of every segment and publishes it. 
* During initial download, Client chooses 'l' segments to store. Constructs merkle
* tree from all 'n' segments, and stores Merkle proofs for each of its 'l' segments.
* 
* A Merkle proof consists of a string of a concatenated series of 256bit hashes.
* 
* During mining, the Client generates nonce's denoted by 's'.
* 
* 
* 
* 
* 
* 
*  
*/

class CKey {

};

// class CPubKey {

// };

// ==================================================================================

ostream& operator<<(ostream& os, const vector<unsigned char>& v) {
	for (int i = 0; i < v.size(); i++) {
		os << v[i];
	}
	return os;
}

// ==================================================================================

CKey 					ck 				 ;  // The client's CKey. Can be used to generate pk and sk. Used for signing.
CPubKey  				pk 				 ;  // public key of client. Used for verifying.
int 					n 			= 586;	// total no. of segments.
const uint32_t 			l 			=  20;	// no. of segments each client stores.
const uint32_t 			k 			=   5;  // no. of challenges.
int 					u[l]		 	 ;  // indices of segments which the client stores.
string 					m_proof[l]		 ;  // merkle proofs of segments which the client stores.
int 					r[k+1]		 	 ;  // indices of challenged segments.
uint256 				h[k] 			 ;  // hashes used for signing and generating challenge indices.
vector<unsigned char> 	sig[k+1] 		 ;  // array of signatures generated by calling ck.Sign

FILE*  					fp 				 ;  // pointer to the file segments that will be read in and hashed.
struct stat 			status 			 ;	// finding file size
int 					filesize 	=	0;  // size of the buffer
unsigned char* 			buffer 			 ;  // to read the file into
vector<unsigned char*> 	files(k)		 ;

int 					nNonce 		= 	0;

// ==================================================================================

int main() {
	CHash256 u_hasher, base_hasher;
	uint256 hash, zerohash;
	uint64_t hashvalue;

	sig[0] = {0};

	u_hasher.Write(pk.begin(), pk.size());
	cout << "\n";
	for (uint32_t i = 0; i < l; i++) {
	    CHash256(u_hasher).Write((unsigned char*)&i, 4).Finalize((unsigned char*)&hash);
	    // cout << hash.ToString() << "\n";
	    hashvalue = hash.GetHash(zerohash);
	    // cout << hashvalue << "\n\n";
		u[i] = hashvalue % n;
	}

	for (int i = 0; i < l; i++) {
		cout << "u[" << i << "] = " << u[i] << "\n";
	}
	cout << "\n";

	// CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);
    // ss << *pblock;
    // assert(ss.size() == 80);
    // base_hasher.Write((unsigned char*)&ss[0], 76);
	base_hasher.Write(pk.begin(), pk.size());
	CHash256(base_hasher).Write((unsigned char*)&nNonce, 4).Finalize((unsigned char*)&hash);
	hashvalue = hash.GetHash(zerohash);
	r[0] = u[hashvalue % l];

	/*
	* 'u' contains the indices of the segments that the Client is storing.
	* r[0]			= u[H(puz||pk||s) mod l]
	* base_hasher 	= H(puz||pk)  				since this is common
	*/

	for (int i = 0; i < k; i++) {
		CHash256 hasher(base_hasher);
		hasher.Write((unsigned char*)(&(sig[i])), sig[i].size());
		fp = fopen(filepath, "rb");
		if (fp == NULL) {
			printf("===========================\nERROR: UNABLE TO OPEN FILE.\n\n");
			exit(0);
		}
		if (filesize == 0) {
			stat(filepath, &status);
			filesize = status.st_size;
		}

		buffer = (char*)malloc(sizeof(unsigned char)*filesize);
		memset((void*)buffer, 0, sizeof(buffer));
		fread((void*)buffer, sizeof(char), sizeof(buffer), fp);
		fclose(fp);
		files[i] = buffer;
		hasher.Write(buffer, sizeof(buffer));
		hasher.Finalize((unsigned char*)&hash);
		h[i] = hash;
		
		ck.Sign(h[i], sig[i+1]);

		hasher = CHash256(base_hasher);
		hasher.Write((unsigned char*)(&(sig[i+1])), sig[i+1].size());
		hasher.Finalize((unsigned char*)&hash);
		hashvalue = hash.GetHash(zerohash);
		r[i+1] = u[hashvalue % l];

		/*
		* h[i]		= H(puz||pk||σ[i−1]||F[r[i]])
		* σ[i] 		= sign_sk(h[i]))
		* r[i+1] 	= u[H(puz||pk||σ[i]) mod l]
		*/
	}



	return 0;
}
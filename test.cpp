/*
* g++ -std=c++11 test.cpp $(pkg-config --libs libcrypto)
*/

#include <vector>
#include <sys/stat.h>
#include "src/secp256k1/include/secp256k1.h"
#include "src/uint256.cpp"
#include "src/hash.cpp"
#include "src/streams.h"
#include "src/arith_uint256.cpp"
// #include "src/key.h"
#include <iostream>
using namespace std;

// static secp256k1_context_t* secp256k1_context = NULL;

// bool CKey::Check(const unsigned char *vch) {
//     return eccrypto::Check(vch);
// }

// void CKey::MakeNewKey(bool fCompressedIn) {
//     RandAddSeedPerfmon();
//     do {
//         GetRandBytes(vch, sizeof(vch));
//     } while (!Check(vch));
//     fValid = true;
//     fCompressed = fCompressedIn;
// }

// bool CKey::SetPrivKey(const CPrivKey &privkey, bool fCompressedIn) {
//     if (!secp256k1_ec_privkey_import(secp256k1_context, (unsigned char*)begin(), &privkey[0], privkey.size()))
//         return false;
//     fCompressed = fCompressedIn;
//     fValid = true;
//     return true;
// }

// CPrivKey CKey::GetPrivKey() const {
//     assert(fValid);
//     CPrivKey privkey;
//     int privkeylen, ret;
//     privkey.resize(279);
//     privkeylen = 279;
//     ret = secp256k1_ec_privkey_export(secp256k1_context, begin(), (unsigned char*)&privkey[0], &privkeylen, fCompressed);
//     assert(ret);
//     privkey.resize(privkeylen);
//     return privkey;
// }

// CPubKey CKey::GetPubKey() const {
//     assert(fValid);
//     CPubKey result;
//     int clen = 65;
//     int ret = secp256k1_ec_pubkey_create(secp256k1_context, (unsigned char*)result.begin(), &clen, begin(), fCompressed);
//     assert((int)result.size() == clen);
//     assert(ret);
//     assert(result.IsValid());
//     return result;
// }






// ==================================================================================

/*
* Server breaks file into n = rf segments.
* For testing, r = 2, f = 293, size_of_segment = 2176 bytes
*
* Server computes hash of every segment and publishes it. 
* During initial download, Client chooses 'l' segments to store. Constructs merkle
* tree from all 'n' segments, and stores Merkle proofs for each of its 'l' segments.
* 
* A Merkle proof consists of a string of a concatenated series of 256bit hashes.
* 
* During mining, the Client generates nonce's denoted by 's'.
* 
* 
* 
* 
* 
* 
*  
*/

class CKey {
  public:
  	void MakeNewKey(bool fCompressed) {}
  	void Sign(uint256 u, vector<unsigned char> v) {}
  	CPubKey GetPubKey() const {return CPubKey();}
};

// class CPubKey {

// };

// ==================================================================================

ostream& operator<<(ostream& os, const vector<unsigned char>& v) {
	for (int i = 0; i < v.size(); i++) {
		os << v[i];
	}
	return os;
}

// ==================================================================================

CKey 					ck 					 ;  // The client's CKey. Can be used to generate pk and sk. Used for signing.
CPubKey  				pk 					 ;  // public key of client. Used for verifying.
int 					n 				=1174;	// total no. of segments.
const uint32_t 			l 				=  20;	// no. of segments each client stores.
const uint32_t 			k 				=   5;  // no. of challenges.
int 					u[l]			 	 ;  // indices of segments which the client stores.
string 					m_proof[l]			 ;  // merkle proofs of segments which the client stores.
int 					r_u_index[k+1]	 	 ; 	// values by which 'u' will be indexed
int 					r[k+1]			 	 ;  // indices of challenged segments.
uint256 				h[k] 				 ;  // hashes used for signing and generating challenge indices.
vector<unsigned char> 	sig[k+1] 			 ;  // array of signatures generated by calling ck.Sign

FILE*  					fp 					 ;  // pointer to the file segments that will be read in and hashed.
struct stat 			status 				 ;	// finding file size
int 					filesize 		=	0;  // size of the buffer
unsigned char* 			buffer 				 ;  // to read the file into
vector<unsigned char*> 	files(k)			 ;
char*					filenamePaddingBuf 	 ;
int 					filenamePadding 	 ;
char* 					filepath 			 ;

int 					nNonce 			= 	0;
string 					baseFilepath	=  "/home/saad/Desktop/Jerasure-1.2/Examples/Coding/";


// ==================================================================================

int main() {
	CHash256 u_hasher, base_hasher, ticket_hasher;
	uint256 hash, zerohash;
	uint64_t hashvalue;
	arith_uint256 hashTarget = arith_uint256().SetCompact(0x1f00ffff);
	cout << "\nHASHTARGET = " << ArithToUint256(hashTarget).ToString() << "\n\n";
		
	for (nNonce; nNonce >= 0; nNonce++)
	{
		/*
		* baseFilepath will need to be configured somehow to point at the directory
		* where each Client stores his share of the data.
		*/
		filenamePaddingBuf = (char*) malloc(sizeof(char)*10);
		filepath = (char*) malloc(sizeof(char)*20 + baseFilepath.length());
		sprintf(filenamePaddingBuf, "%d", n);
		filenamePadding = strlen(filenamePaddingBuf);

		/* %%%%%%%%%%%%%
		* The wallet's key should be used, not a new one. This is a dummy implementation
		* anyways.
		*/
		ck.MakeNewKey(false);
		pk = ck.GetPubKey();
		for (int i = 0; i < k+1; i++) {
			sig[i] = vector<unsigned char> (72,'0'+i);
		}
		// %%%%%%%%%%%%%% To be deleted. Dummy implementation of Sign.


		// sig[0] = {0};

		u_hasher.Write(pk.begin(), pk.size());
		
		for (uint32_t i = 0; i < l; i++) {
		    CHash256(u_hasher).Write((unsigned char*)&i, 4).Finalize((unsigned char*)&hash);
		    hashvalue = hash.GetHash(zerohash);
		    u[i] = hashvalue % n;
		}

		/*		
		*	for (int i = 0; i < l; i++) {
		*		cout << "u[" << i << "] = " << u[i] << "\n";
		*	}
		*	cout << "\n";
		*/

		CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);
	    // ss << *pblock;
	    // assert(ss.size() == 80);
	    // base_hasher.Write((unsigned char*)&ss[0], 76);
		base_hasher.Write(pk.begin(), pk.size());
		CHash256(base_hasher).Write((unsigned char*)&nNonce, 4).Finalize((unsigned char*)&hash);
		hashvalue = hash.GetHash(zerohash);
		r_u_index[0] = hashvalue % l;
		r[0] = u[r_u_index[0]];

		/*
		* 'u' contains the indices of the segments that the Client is storing.
		* r[0]			= u[H(puz||pk||s) mod l]
		* base_hasher 	= H(puz||pk)  				since this is common
		*/

		for (int i = 0; i < k; i++) {
			CHash256 hasher(base_hasher);
			hasher.Write((unsigned char*)(&(sig[i])), sig[i].size());
			sprintf(filepath, "%sPermacoin_%0*d.pdf", baseFilepath.c_str(), filenamePadding, r[i]);
			// printf("r[%d] = %d\n", i, r[i]);
			// printf("%s\n", filepath);
			fp = fopen(filepath, "rb");
			if (fp == NULL) {
				printf("===========================\nERROR: UNABLE TO OPEN FILE.\n\n");
				exit(0);
			}
			if (filesize == 0) {
				stat(filepath, &status);
				filesize = status.st_size;
			}

			buffer = (unsigned char*)malloc(sizeof(unsigned char)*filesize);
			memset((void*)buffer, 0, sizeof(buffer));
			fread((void*)buffer, sizeof(char), sizeof(buffer), fp);
			fclose(fp);
			files[i] = buffer;
			hasher.Write(buffer, sizeof(buffer));
			hasher.Finalize((unsigned char*)&hash);
			h[i] = hash;
			
			ck.Sign(h[i], sig[i+1]);

			hasher = CHash256(base_hasher);
			hasher.Write(&(sig[i+1][0]), sig[i+1].size());
			hasher.Finalize((unsigned char*)&hash);
			hashvalue = hash.GetHash(zerohash);
			r_u_index[i+1] = hashvalue % l;
			r[i+1] = u[r_u_index[i+1]];

			/*
			* h[i]		= H(puz||pk||σ[i−1]||F[r[i]])
			* σ[i] 		= sign_sk(h[i]))
			* r[i+1] 	= u[H(puz||pk||σ[i]) mod l]
			*/
		}

		CDataStream ss1(1, 2);
		string br = "\n\n";
		ss1 << br << pk << br;
		ss1 << nNonce << br;
		for (int i = 0; i < k; i++) {
			ss1.write((char*)files[i], filesize);
			ss1 << br << sig[i+1];
			ss1 << br << m_proof[r_u_index[i+1]];
		}

		// ticket_hasher.Write((unsigned char*)&ss[0], 76);
		ticket_hasher.Write((unsigned char*)(ss1.str().c_str()), ss1.size());
		ticket_hasher.Finalize((unsigned char*)&hash);
		cout << "\nTICKET = " << hash.ToString();
		
		// for (int i = 20; i < 40; i++) {
		// 	unsigned int nSize = 2;
		// 	for (int j = 0; j < i; j++) {
		// 		nSize *= 2;
		// 	}
		// 	unsigned int nSize2 = nSize >> 24;
		// 	cout << "nSize = " << nSize << "\n";
		// 	cout << "nSize2 = " << nSize2 << "\n";
		// 	uint32_t nSize3 = nSize2 & 0x007fffff;
		// 	cout << "nSize3 = " << nSize3 << "\n\n";
		// }
		
		if (UintToArith256(hash) <= hashTarget) {
			cout << "\n\nSUCCESS\n\n";
			break;
		}
		/*
		* Clearing used memory.
		*/
		// printf("\n");
		for (int i = 0; i < k; i++) {
			delete files[i];
		}
		delete filenamePaddingBuf;
		delete filepath;
	}

	return 0;
}
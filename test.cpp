/*
* g++ -std=c++11 test.cpp $(pkg-config --libs libcrypto)
*/

#include <vector>
#include <sys/stat.h>
#include "src/secp256k1/include/secp256k1.h"
#include "src/uint256.cpp"
#include "src/hash.cpp"
#include "src/streams.h"
#include "src/arith_uint256.cpp"
// #include "src/key.h"
#include <iostream>
#include <fstream>
#include <sstream>
using namespace std;

// static secp256k1_context_t* secp256k1_context = NULL;

// bool CKey::Check(const unsigned char *vch) {
//     return eccrypto::Check(vch);
// }

// void CKey::MakeNewKey(bool fCompressedIn) {
//     RandAddSeedPerfmon();
//     do {
//         GetRandBytes(vch, sizeof(vch));
//     } while (!Check(vch));
//     fValid = true;
//     fCompressed = fCompressedIn;
// }

// bool CKey::SetPrivKey(const CPrivKey &privkey, bool fCompressedIn) {
//     if (!secp256k1_ec_privkey_import(secp256k1_context, (unsigned char*)begin(), &privkey[0], privkey.size()))
//         return false;
//     fCompressed = fCompressedIn;
//     fValid = true;
//     return true;
// }

// CPrivKey CKey::GetPrivKey() const {
//     assert(fValid);
//     CPrivKey privkey;
//     int privkeylen, ret;
//     privkey.resize(279);
//     privkeylen = 279;
//     ret = secp256k1_ec_privkey_export(secp256k1_context, begin(), (unsigned char*)&privkey[0], &privkeylen, fCompressed);
//     assert(ret);
//     privkey.resize(privkeylen);
//     return privkey;
// }

// CPubKey CKey::GetPubKey() const {
//     assert(fValid);
//     CPubKey result;
//     int clen = 65;
//     int ret = secp256k1_ec_pubkey_create(secp256k1_context, (unsigned char*)result.begin(), &clen, begin(), fCompressed);
//     assert((int)result.size() == clen);
//     assert(ret);
//     assert(result.IsValid());
//     return result;
// }






// ==================================================================================

/*
* Server breaks file into n = rf segments.
* For testing, r = 2, f = 293, size_of_segment = 2176 bytes
*
* Server computes hash of every segment and publishes it. 
* During initial download, Client chooses 'l' segments to store. Constructs merkle
* tree from all 'n' segments, and stores Merkle proofs for each of its 'l' segments.
* 
* A Merkle proof consists of a string of a concatenated series of 256bit hashes.
* 
* During mining, the Client generates nonce's denoted by 's'.
* 
* 
* 
* 
* 
* 
*  
*/

class CKey {
  public:
  	void MakeNewKey(bool fCompressed) {}
  	void Sign(uint256 u, vector<unsigned char> v) {}
  	CPubKey GetPubKey() const {return CPubKey();}
};

// class CPubKey {

// };

// ==================================================================================

ostream& operator<<(ostream& os, const vector<unsigned char>& v) {
	for (int i = 0; i < v.size(); i++) {
		os << v[i];
	}
	return os;
}


uint256 CheckMerkleBranch(uint256 hash, const vector<uint256>& vMerkleBranch, int nIndex)
{
    if (nIndex == -1)
        return uint256();
    for (vector<uint256>::const_iterator it(vMerkleBranch.begin()); it != vMerkleBranch.end(); ++it)
    {
        if (nIndex & 1)
            hash = Hash(BEGIN(*it), END(*it), BEGIN(hash), END(hash));
        else
            hash = Hash(BEGIN(hash), END(hash), BEGIN(*it), END(*it));
        nIndex >>= 1;
    }
    return hash;
}

// ==================================================================================

CKey 					ck 					 ;  // The client's CKey. Can be used to generate pk and sk. Used for signing.
CPubKey  				pk 					 ;  // public key of client. Used for verifying.
int 					n 				=1174;	// total no. of segments.
const uint32_t 			l 				=  20;	// no. of segments each client stores.
const uint32_t 			k 				=   5;  // no. of challenges.
int 					u[l]			 	 ;  // indices of segments which the client stores.
vector<string> 			m_proof[l]			 ;  // merkle proofs of segments which the client stores.
int 					r_u_index[k+1]	 	 ; 	// values by which 'u' will be indexed
int 					r[k+1]			 	 ;  // indices of challenged segments.
uint256 				h[k] 				 ;  // hashes used for signing and generating challenge indices.
vector<unsigned char> 	sig[k+1] 			 ;  // array of signatures generated by calling ck.Sign
string 					merkleRoot			 ;  // root hash of the merkle tree

FILE*  					fp 					 ;  // pointer to the file segments that will be read in and hashed.
struct stat 			status 				 ;	// finding file size
int 					filesize 		=	0;  // size of the buffer
unsigned char* 			buffer 				 ;  // to read the file into
vector<unsigned char*> 	files(k)			 ;
char*					filenamePaddingBuf 	 ;
int 					filenamePadding 	 ;
char* 					filepath 			 ;
ifstream 				fs 					 ;

int 					nNonce 			= 	0;
string 					baseFilepath	=  "/home/saad/Desktop/Jerasure-1.2/Examples/Coding/";


// ==================================================================================

int main() {
	CHash256 u_hasher, base_hasher;
	uint256 hash, zerohash;
	uint64_t hashvalue;
	arith_uint256 hashTarget = arith_uint256().SetCompact(0x1f0fffff);
	cout << "\nHASHTARGET = " << ArithToUint256(hashTarget).ToString() << "\n\n";
		
	/*
	* baseFilepath will need to be configured somehow to point at the directory
	* where each Client stores his share of the data.
	*/
	filenamePaddingBuf = (char*) malloc(sizeof(char)*10);
	filepath = (char*) malloc(sizeof(char)*30 + baseFilepath.length());
	sprintf(filenamePaddingBuf, "%d", n);
	filenamePadding = strlen(filenamePaddingBuf);

	sprintf(filepath, "%sPermacoin.pdf_root_proof.txt", baseFilepath.c_str());
	fs.open(filepath);
	getline(fs, merkleRoot);
	fs.close();
	cout << "merkleRoot = " << merkleRoot << "\n\n";
	
	/* %%%%%%%%%%%%%
	* The wallet's key should be used, not a new one. This is a dummy implementation
	* anyways.
	*/
	ck.MakeNewKey(false);
	pk = ck.GetPubKey();
	// %%%%%%%%%%%%%

	u_hasher.Write(pk.begin(), pk.size());
		
	for (uint32_t i = 0; i < l; i++) {
	    CHash256(u_hasher).Write((unsigned char*)&i, 4).Finalize((unsigned char*)&hash);
	    hashvalue = hash.GetHash(zerohash);
	    u[i] = hashvalue % n;

		/*
		* Loading the Merkle Proofs for the stored segments.
		*/

		sprintf(filepath, "%sPermacoin_%0*d.pdf_proof.txt", baseFilepath.c_str(), filenamePadding, u[i]);
		string s;
		fs.open(filepath);
		while (getline(fs, s)) {
			m_proof[i].push_back(s);
		}
		fs.close();
	}

	/*		
		for (int i = 0; i < l; i++) {
			cout << "u[" << i << "] = " << u[i] << "\n";
			cout << "proof:\n";
			for (int j = 0; j < m_proof[i].size(); j++) {
				cout << "\t" << m_proof[i][j] << "\n";
			}
			cout << "\n";
		}
		cout << "\n";
	*/

	CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);
    // ss << *pblock;
    // assert(ss.size() == 80);
    // base_hasher.Write((unsigned char*)&ss[0], 76);
	base_hasher.Write(pk.begin(), pk.size());

	for (nNonce; nNonce >= 0; nNonce++)
	{
		CHash256 ticket_hasher;

		// %%%%%%%%%%%%%%
		for (int i = 0; i < k+1; i++) {
			sig[i] = vector<unsigned char> (72,'0'+i);
		}
		// %%%%%%%%%%%%%% To be deleted. Dummy implementation of Sign.

		// sig[0] = {0};	

		CHash256(base_hasher).Write((unsigned char*)&nNonce, 4).Finalize((unsigned char*)&hash);
		hashvalue = hash.GetHash(zerohash);
		r_u_index[0] = hashvalue % l;
		r[0] = u[r_u_index[0]];

		/*
		* 'u' contains the indices of the segments that the Client is storing.
		* r[0]			= u[H(puz||pk||s) mod l]
		* base_hasher 	= H(puz||pk)  				since this is common
		*/

		for (int i = 0; i < k; i++) {
			CHash256 hasher(base_hasher);
			hasher.Write((unsigned char*)(&(sig[i])), sig[i].size());
			sprintf(filepath, "%sPermacoin_%0*d.pdf", baseFilepath.c_str(), filenamePadding, r[i]);
			
			// cout << "r[" << i << "] = " << r[i] << "\n";

			fp = fopen(filepath, "rb");
			if (fp == NULL) {
				printf("===========================\nERROR: UNABLE TO OPEN FILE.\n\n");
				exit(0);
			}
			if (filesize == 0) {
				stat(filepath, &status);
				filesize = status.st_size;
			}

			buffer = (unsigned char*)malloc(sizeof(unsigned char)*filesize);
			memset((void*)buffer, 0, filesize);
			fread((void*)buffer, sizeof(char), filesize, fp);
			fclose(fp);
			files[i] = buffer;
			hasher.Write(buffer, filesize);
			hasher.Finalize((unsigned char*)&hash);
			h[i] = hash;
			ck.Sign(h[i], sig[i+1]);

			hasher = CHash256(base_hasher);
			hasher.Write(&(sig[i+1][0]), sig[i+1].size());
			hasher.Finalize((unsigned char*)&hash);
			hashvalue = hash.GetHash(zerohash);
			r_u_index[i+1] = hashvalue % l;
			r[i+1] = u[r_u_index[i+1]];

			/*
			* h[i]		= H(puz||pk||σ[i−1]||F[r[i]])
			* σ[i] 		= sign_sk(h[i]))
			* r[i+1] 	= u[H(puz||pk||σ[i]) mod l]
			*/


			/*
			* Validate the challenged proofs.
			*/

			vector<uint256> proof;
			for (int j = 0; j < m_proof[r_u_index[i]].size(); j++) {
				proof.push_back(uint256S(m_proof[r_u_index[i]][j]));
			}
			
			CHash256 merkleHasher;
			uint256 merkleTestHash;
			merkleHasher.Write(buffer, sizeof(buffer));
			merkleHasher.Finalize((unsigned char*)&merkleTestHash);
			uint256 supposedRootHash = CheckMerkleBranch(merkleTestHash, proof, r[i]);
			assert(supposedRootHash.ToString() == merkleRoot);
		}

		CDataStream ss1(1, 2);
		
		// PK
		ss1 << '\n' << pk << '\n';

		// NONCE
		char temp[10];
		sprintf(temp, "%d", nNonce);
		for (int i = 0; i < strlen(temp); i++) {
			ss1 << temp[i];
		}
		ss1 << '\n';

		// FILE, SIGNATURE, PROOF
		for (int i = 0; i < k; i++) {
			ss1.write((char*)files[i], filesize);
			ss1 << '\n' << sig[i+1];
			ss1 << '\n';
			for (int j = 0; j < m_proof[r_u_index[i+1]].size(); j++) {
				for (char c : m_proof[r_u_index[i+1]][j]) {
					ss1 << c;
				}
				ss1 << ',';
			}
		}
		// cout << "STREAM = " << ss1.str() << "\n";
		// ticket_hasher.Write((unsigned char*)&ss[0], 76);
		ticket_hasher.Write((unsigned char*)(ss1.str().c_str()), ss1.size());
		ticket_hasher.Finalize((unsigned char*)&hash);
		cout << "\nTICKET = " << hash.ToString();
		
		if (UintToArith256(hash) <= hashTarget) {
			cout << "\n\nSUCCESS\n\n";
			cout << ss1.str() << "\n";
			break;
		}

		/*
		* Clearing used memory.
		*/
		
		for (int i = 0; i < k; i++) {
			delete files[i];
		}
	}

	return 0;
}